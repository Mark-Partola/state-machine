<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>


<script src="dist/bundle.js"></script>
</body>
</html>

<!--import graphLib from 'graphlib';

class StateMachine {

    monitor = true;

    constructor () {
        this.graph = new graphLib.Graph();

        // Ноды
        this.graph.setNode("A", { trigger: (data) => new Promise((res, rej) => {

            console.log('Логика для А');

            res({
                next: 'B',
                data: [1,2,3]
            });

        }) });

        this.graph.setNode("B", { trigger: (data) => new Promise((res, rej) => {

            console.log('Логика для B');

            res({
                data: "Finish"
            });

        }) });

        this.graph.setNode("C", { trigger: (data) => new Promise((res, rej) => {
            res({
                data: "State C finished"
            });
        }) });

        this.graph.setNode("D",{ trigger: (data) => new Promise((res, rej) => {
            res("Логика для D");
        }) });

        // Транзишены
        this.graph.setEdge("A", "C", {
            onEnter() {},
            onLeave() {}
        });

        this.graph.setEdge("A", "B", {
            onEnter() { console.log("onEnter A->B") },
            onLeave() { console.log("onLeave A->B") }
        });

        this.graph.setEdge("C", "A", {
            onEnter() {},
            onLeave() {}
        });

        this.graph.setEdge("C", "B", {
            onEnter() {},
            onLeave() {}
        });
    }

    setState(nodeName) {

        return new Promise((resolve, reject) => {
            if (this.monitor) {
                reject("Monitor is reserved");
            }

            this._changeState(nodeName);
        });
    }

    _changeState () {
        let onTransition = this.getTransition(this.currentNodeName, nodeName);

        if (onTransition) {
            onTransition.onLeave && onTransition.onLeave();
            onTransition.onEnter && onTransition.onEnter();
        }

        this.currentNodeName = nodeName;

        let currentTriggerPromise = this.getCurrentState().trigger();

        return new Promise((resolve, reject) => {
            currentTriggerPromise
                .then((result) => this._tryTransition({ result, resolve, reject }))
                .catch((err) => reject(err));
        });
    }

    _tryTransition (params) {
        let { result, resolve, reject } = params;

        if (result.next) {
            if (this.checkTransition(result.next)) {
                resolve(this.setState(result.next));
            } else {
                reject('Transition not found');
            }
        } else {
            resolve(result);
        }
    }

    getCurrentPotentialTransitions() {
        let edges = this.graph.outEdges(this.currentNodeName);
        return edges.map((edge) => {
            return {
                source: edge.v,
                target: edge.w
            };
        });
    }

    getTransition(source, target) {
        return this.graph.edge(source, target);
    }

    getCurrentState() {
        return this.graph.node(this.currentNodeName);
    }

    checkTransition(target) {
        let potentialTransitions = this.getCurrentPotentialTransitions();

        for(let i = 0; i < potentialTransitions.length; i++) {
            if (potentialTransitions[i].target === target) {
                return true;
            }
        }

        return false;
    }
}

export default StateMachine;-->